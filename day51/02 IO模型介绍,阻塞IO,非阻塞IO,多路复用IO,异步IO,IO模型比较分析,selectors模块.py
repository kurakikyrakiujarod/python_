# 一、IO模型介绍


# 为了更好地了解IO模型，我们需要事先回顾下：同步、异步、阻塞、非阻塞
# 同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？

# 本文讨论的背景是Linux环境下的network IO
# Stevens在文章中一共比较了五种IO Model：
# blocking IO           阻塞IO
# nonblocking IO       非阻塞IO
# IO multiplexing      IO多路复用
# signal driven IO     信号驱动IO
# asynchronous IO     异步IO

# 由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model

# 再说一下IO发生时涉及的对象和步骤
# 对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象
# 一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)

# 当一个read操作发生时，该操作会经历两个阶段
# 1）等待数据准备 (Waiting for the data to be ready)
# 2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)
# 记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况


# 二、阻塞IO


# 在linux中，默认情况下所有的socket都是blocking

# 用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据
# 对于network io来说，很多时候数据在一开始还没有到达
# （比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来
# 而在用户进程这边，整个进程会被阻塞
# 当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来

# 所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了


# ps：所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回

# 实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的
# 这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求

# 一个简单的解决方案
# 在服务器端使用多线程（或多进程）
# 多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接

# 该方案的问题是
# 开启多进程或都线程的方式，在遇到要同时响应成百上千连接请求时
# 无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态

# 改进方案
# 很多程序员可能会考虑使用“线程池”或“连接池”
# “线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务
# “连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率
# 这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等

# 改进后方案其实也存在着问题
# “线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用
# 而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少
# 所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小


# 三、非阻塞IO


# 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error
# 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果
# 用户进程判断结果是一个error时，它就知道数据还没有准备好
# 于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作
# 一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存

# 也就是说非阻塞的recvform系统调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error
# 进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。
# 重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询
# 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。
# 需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态

# 所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有

# 非阻塞IO实例

# 但是非阻塞IO模型绝不被推荐
# 我们不能否定其优点：
# 能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在“”同时“”执行）
# 但是也难掩其缺点：
# 1. 循环调用recv()将大幅度推高CPU占用率
# 2. 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低

# 非阻塞IO虽然完成了异步，但是它非常耗费CPU

# 在这个方案中recv() 更多的是起到检测“操作是否完成”的作用
# 实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select() 多路复用模式，可以一次检测多个连接是否活跃

# 四、多路复用IO


# IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了，有些地方也称这种IO方式为事件驱动IO
# select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO
# 它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程

# 当用户进程调用了select，那么整个进程会被block
# 而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回
# 这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程

# 这个图和blockingIO的图其实并没有太大的不同，事实上还更差一些
# 因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)
# 但是，用select的优势在于它可以同时处理多个connection

# 强调：

# 1.如果处理的连接数不是很高的话
# 使用select/epoll的web server不一定比使用multi-threading + blockingIO的web server性能更好，可能延迟还更大
# select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接
# 2. 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，
# 但是，如上图所示，整个用户的process其实是一直被block的，只不过process是被select这个函数block，而不是被socket IO给block

# 结论: select的优势在于可以处理多个连接，不适用于单个连接

# select网络IO模型

# select监听fd变化的过程分析：
# 用户进程创建socket对象，拷贝监听的fd到内核空间
# 每一个fd会对应一张系统文件表，内核空间的fd响应到数据后，就会发送信号给用户进程数据已到
# 用户进程再发送系统调用，比如（accept）将内核空间的数据copy到用户空间，同时作为接受数据端内核空间的数据清除
# 这样重新监听时fd再有新的数据又可以响应到了（发送端因为基于TCP协议所以需要收到应答后才会清除）

# 该模型的优点：
# 相比其他模型，使用select的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务
# 如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值

# 该模型的缺点：

# 首先select()接口并不是实现“事件驱动”的最好选择
# 因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄

# 很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…
# 如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。
# 遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难

# 其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的

# select - windows/linux/ios
# poll - linux/ios 内部采用了一种数据结构的优化，让能监听的数据量变多了
# epoll -linux 回调函数

# 高级别的是epoll，它是效率最快的


# 五、异步IO


# 用户进程发起read操作之后，立刻就可以开始去做其它的事
# 而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block
# 然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存
# 当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了


# 六、IO模型比较分析


# 到目前为止，已经将四个IO Model都介绍完了。
# 现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪

# 先回答最简单的这个：blocking vs non-blocking
# 前面的介绍中其实已经很明确的说明了这两者的区别
# 调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回

# 再说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义

# 两者的区别就在于synchronous IO做“IO operation”的时候会将process阻塞
# 按照这个定义，四个IO模型可以分为两大类
# 之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO这一类，而 asynchronous I/O后一类

# 有人可能会说，non-blocking IO并没有被block啊
# 这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作
# 就是例子中的recvfrom这个system call
# non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程
# 但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中
# 这个时候进程是被block了，在这段时间内，进程是被block的
# 而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成
# 在这整个过程中，进程完全没有被block

# 各个IO Model的比较
# 经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的
# 在non-blocking IO中, 虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check
# 并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存
# 而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知
# 在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据


# 七、selectors模块

# select,poll,epoll

# 总结：
# （1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替
# 而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替
# 但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程
# 虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合
# 而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升

# （2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次
# 而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次
# （在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销

# 这三种IO多路复用模型在不同的平台有着不同的支持
# 而epoll在windows下就不支持，好在我们有selectors模块，帮我们默认选择当前平台下最合适的

# 基于selectors模块实现聊天