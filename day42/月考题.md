# **python全栈11期月考题**

## 单例模式

```python
class Singleton:
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_inistance'):
            cls._inistance = super().__new__(cls)
        return cls._inistance


s0 = Singleton()
s1 = Singleton()
print(id(s0))
print(id(s1))
# 1706285819776
# 1706285819776
```

## 面向对象复习

```python
class Foo(object):
    pass


class Bar(Foo):
    pass


# issubclass(sub, super)检查sub类是否是super类的派生类
print(issubclass(Bar, Foo))
# True
```

## 反射

python面向对象中的反射：通过字符串的形式操作对象相关的属性。

```python
class Foo:
    f = '类的静态变量'

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def say_hi(self):
        print('hi,%s' % self.name)


obj = Foo('egon', 73)
# 检测是否含有某属性
print(hasattr(obj, 'name'))
print(hasattr(obj, 'say_hi'))
# True
# True
```

```python
# 获取属性
n = getattr(obj, 'name')
print(n)
func = getattr(obj, 'say_hi')
func()
# egon
# hi,egon
```

python中的一切事物都是对象（都可以使用反射）

```python
print(hasattr(Foo, 'f'))
print(hasattr(Foo, 'say_hi'))
# True
# True
```

```python
print(getattr(obj, 'aaaaaaaa', '不存在啊'))
# 不存在啊
```

```python
# 设置属性
setattr(obj, 'sb', True)
setattr(obj, 'show_name', lambda self: self.name + 'sb')
print(obj.__dict__)
print(obj.show_name(obj))
# {'name': 'egon', 'age': 73, 'sb': True, 'show_name': <function <lambda> at 0x000001A6C1292E18>}
# egonsb
```

```python
# 删除属性
delattr(obj, 'age')
delattr(obj, 'show_name111')  # 删除不存在的属性会报错
```

## 反射模块

反射当前模块成员

```python
import sys


def s1():
    print('s1')


def s2():
    print('s2')


this_module = sys.modules[__name__]
print(this_module)
print(hasattr(this_module, 's1'))
getattr(this_module, 's2')()
# <module '__main__'>
# True
# s2
```

导入其他模块，利用反射查找该模块是否存在某个方法。

module_test.py

```python
def test():
    print('from the test')
```

```python
import module_test as obj

print(hasattr(obj, 'test'))
getattr(obj, 'test')()

# True
# from the test
```

## str、repr、format

```
__str__和__repr__ 改变对象的字符串显示__str__,__repr__ 
自定制格式化字符串__format__
```

```python
format_dict = {
    'nat': '{obj.name}-{obj.adr}-{obj.typ}',  # 学校名-学校地址-学校类型
    'tna': '{obj.typ}:{obj.name}:{obj.adr}',  # 学校类型:学校名:学校地址
    'tan': '{obj.typ}/{obj.adr}/{obj.name}',  # 学校类型/学校地址/学校名
}


class School:
    def __init__(self, name, adr, typ):
        self.name = name
        self.adr = adr
        self.typ = typ

    def __repr__(self):
        return 'School(%s,%s)' % (self.name, self.adr)

    def __str__(self):
        return '(%s,%s)' % (self.name, self.adr)

    def __format__(self, format_spec):
        # if format_spec
        if not format_spec or format_spec not in format_dict:
            format_spec = 'nat'
        fmt = format_dict[format_spec]
        return fmt.format(obj=self)


s1 = School('oldboy1', '北京', '私立')
print('from repr: ', repr(s1))
print('from str: ', str(s1))
print(s1)
# from repr:  School(oldboy1,北京)
# from str:  (oldboy1,北京)
# (oldboy1,北京)
```

```
str函数或者print函数--->obj.__str__()
repr或者交互式解释器--->obj.__repr__()
如果__str__没有被定义，那么就会使用__repr__来代替输出
注意：这俩方法的返回值必须是字符串，否则抛出异常。
```

```python
print(format(s1, 'nat'))
print(format(s1, 'tna'))
print(format(s1, 'tan'))
print(format(s1, 'asfdasdffd'))
# oldboy1-北京-私立
# 私立:oldboy1:北京
# 私立/北京/oldboy1
# oldboy1-北京-私立
```

```python
# %s和%r
class B:
    def __str__(self):
        return 'str : class B'

    def __repr__(self):
        return 'repr : class B'


b = B()
print('%s' % b)
print('%r' % b)
# str : class B
# repr : class B
```

## del

当对象在内存中被释放时，自动触发执行。此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行。所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。

```python
class Foo:

    def __del__(self):
        print('执行我啦')


f1 = Foo()
del f1
print('------->')

# 执行我啦
# ------->
```

## item系列

```python
class Foo:
    def __init__(self, name):
        self.name = name

    def __getitem__(self, item):
        return self.__dict__[item]

    def __setitem__(self, key, value):
        self.__dict__[key] = value

    def __delitem__(self, key):
        print('del obj[key]时,我执行')
        self.__dict__.pop(key)

    def __delattr__(self, item):
        print('del obj.key时,我执行')
        self.__dict__.pop(item)


f1 = Foo('sb')
f1['age'] = 18
print(f1['age'])
f1['age1'] = 19
del f1.age1
del f1['age']
f1['name'] = 'alex'
print(f1.__dict__)
# 18
# del obj.key时,我执行
# del obj[key]时,我执行
# {'name': 'alex'}
```

## new

```python
class A:
    def __init__(self):
        self.x = 1
        print('in init function')

    def __new__(cls, *args, **kwargs):
        print('in new function')
        return object.__new__(cls, *args, **kwargs)
    	# return object.__new__(A, *args, **kwargs)


a = A()
# in new function
# in init function
```

## call

对象后面加括号，触发执行。

```
注：构造方法的执行是由创建对象触发的，即：对象 = 类名() 
而对于 __call__ 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()
```

```python
class Foo:
    def __init__(self):
        pass

    def __call__(self, *args, **kwargs):
        print('__call__')


obj = Foo()  # 执行 __init__
obj()  # 执行 __call__
# __call__
```

## len

```python
class A:
    def __init__(self):
        self.a = 1
        self.b = 2

    def __len__(self):
        print(self.__dict__)
        return len(self.__dict__)


a = A()
print(len(a))
# {'a': 1, 'b': 2}
# 2
```

## hash

```python
class A:
    def __init__(self):
        self.a = 1
        self.b = 2

    def __hash__(self):
        return hash(str(self.a) + str(self.b))


a = A()
print(hash(a))
print(hash('12'))
# -5533544675329711985
# -5533544675329711985
```

## eq

```python
class A:
    def __init__(self):
        self.a = 1
        self.b = 2

    def __eq__(self, obj):
        return self.a == obj.a and self.b == obj.b


a = A()
b = A()
print(a == b)
# True
```

## 纸牌游戏

```python
from collections import namedtuple

Card = namedtuple('Card', ['ranks', 'suits'])
c1 = Card('2', '红心')
c2 = Card('J', '梅花')
print(c1)
print(c2.ranks)
# Card(ranks='2', suits='红心')
# J
```

```python
class FranchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = ['红心', '方块', '梅花', '黑桃']

    def __init__(self):
        self._cards = [Card(rank, suit) for rank in FranchDeck.ranks
                       for suit in FranchDeck.suits]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, item):
        return self._cards[item]


deck = FranchDeck()
print(deck[0])
from random import choice
print(choice(deck))
# Card(ranks='2', suits='红心')
# Card(ranks='9', suits='梅花')
```

## 纸牌游戏2

```python
class FranchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = ['红心', '方板', '梅花', '黑桃']

    def __init__(self):
        self._cards = [Card(rank, suit) for rank in FranchDeck.ranks
                       for suit in FranchDeck.suits]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, item):
        return self._cards[item]

    def __setitem__(self, key, value):
        self._cards[key] = value


deck = FranchDeck()
from random import shuffle

shuffle(deck)
print(deck[:5])
```

<a href="https://blog.csdn.net/zhangxinrun/article/details/6721495">（经典）tcp粘包分析</a>

<a href="https://blog.csdn.net/smileiam/article/details/78226816">（TCP的三次握手、四次挥手--非常详细讲解</a>

<a href="https://www.jianshu.com/p/1e375fb40506">[转载]Python垃圾回收机制--完美讲解!</a>

## 一道面试题

```python
class Person:
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender

    def __hash__(self):
        return hash(self.name + self.gender)

    def __eq__(self, other):
        # if self.name == other.name and self.sex == other.sex: return True
        return self.name == other.name and self.gender == other.gender

p_lst = []
for i in range(84):
    p_lst.append(Person('egon', i, 'male'))

print(len(p_lst), len(set(p_lst)))
for p in set(p_lst):
    print(p.age)
# 84 1
# 0
```

## 打印前一天

利用 python 打印前一天的本地时间，格式为‘2018-01-30’（面试题）

```python
import time

# print(time.localtime(time.time()-24*60*60))
print(time.strftime('%Y-%m-%d', time.localtime(time.time() - 24 * 60 * 60)))
import datetime

# print(datetime.datetime.now())
# print(datetime.datetime.now()-datetime.timedelta(days=1))
d2 = datetime.datetime.now() - datetime.timedelta(days=1)
print(d2.strftime('%Y-%m-%d'))
```

## datetime模块

```python
import datetime

print(datetime.datetime.now())  # 返回一个datetime对象，表示当前的日期和时间
# 2018-10-26 20:45:25.151208
dat = datetime.datetime(2018, 6, 5, 12, 35, 45)  # 传入代表年、月、日、时、分、秒的整数
# 得到特定时刻datetime对象
print(dat)
# 2018-06-05 12:35:45
print(dat.year, dat.month, dat.day, dat.hour, dat.minute, dat.second)
# 2018 6 5 12 35 45
```

```python
import time

dat = datetime.datetime.fromtimestamp(1200000000)
# 表示1970年1月1日0时后1200000000秒的时刻
print(dat)
# 2008-01-11 05:20:00
dt = datetime.datetime.fromtimestamp(time.time())  # 当前时刻的datetime对象
print(dt)
# 2018-10-26 20:49:27.923292

# datetime.datetime.now()和datetime.datetime.fromtimestamp(time.time())做的事情相同
print(datetime.datetime.now())
print(datetime.datetime.fromtimestamp(time.time()))
# 2018-10-26 20:51:23.791149
# 2018-10-26 20:51:23.791149

# datetime模块还提供了timedelta数据类型，表示一段时间而不是一个时刻

dat = datetime.timedelta(days=11, hours=10, minutes=9, seconds=8)
# datetime.timedelta（）函数接受关键字weeks、days、hours、minutes、seconds、milliseconds和microseconds
# 没有month和year关键字参
dt = dat.total_seconds()
tm = str(dat)
print(dat)
print(dt)
print(tm)
print(dat.days)
print(dat.seconds)
print(dat.microseconds)
# 11 days, 10:09:08
# 986948.0
# 11 days, 10:09:08
# 11
# 36548
# 0

dt = datetime.datetime.now()  # 现在的时间
dat = datetime.timedelta(days=1100)  # 也可以加入minutes等参数
day = dt + dat  # 1100天以后的时间，相加得到一个datetime对象
print(day)
# 2021-10-30 20:56:53.758421
```

## 闭包函数

写一个闭包函数 clo，接收整数参数 n ，返回一个函数 foo，foo 函数的功能是把foo参数和n相乘并把结果返回。

```python
def clo(n):
    def foo(m):
        return m*n
    return foo


a = clo(5)
print(a(6))
# 30
```

## 正则表达式

```
提示：<a href="/2.mp3" singer="任贤齐">沧海一声笑</a>
html = '''<div id="songs-list">
 <h2 class="title">经典老歌</h2>
 <p class="introduction">
 经典老歌列表
 </p>
 <ul id="list" class="list-group">
 <li data-view="2">一路上有你</li>
 <li data-view="7">
 <a href="/2.mp3" singer="任贤齐">沧海一声笑</a>
 </li>
 <li data-view="4" class="active">
 <a href="/3.mp3" singer="齐秦">往事随风</a>
 </li>
 <li data-view="6"><a href="/4.mp3" singer="beyond">光辉岁月</a></li>
 <li data-view="5"><a href="/5.mp3" singer="陈慧琳">记事本</a></li>
 <li data-view="5">
 <a href="/6.mp3" singer="邓丽君">但愿人长久</a>
 </li>
 </ul>
</div>'''
```

```python
import re
res = re.findall(r'<a.*?singer="(\w+)">(\w+)</a>', html, re.S)
print(res)
# [('任贤齐', '沧海一声笑'), ('齐秦', '往事随风'), ('beyond', '光辉岁月'), ('陈慧琳', '记事本'), ('邓丽君', '但愿人长久')]
```

```python
s = '<a>wahaha</a>'
pattern = '<(?P<tab>\w+)>(\w+)</(?P=tab)>'
# 要求使用这个名字的分组和前面同名分组中的内容匹配的必须一致
ret = re.findall(pattern, s)
print(ret)
# [('a', 'wahaha')]
```

```python
it = re.finditer(r"\d+", "12a32bc43jf3")
for match in it:
    print(match.group())
# 12
# 32
# 43
# 3
```

##  filter、map 

请写出函数式编程 filter、map 的实例。

```python
nums = range(20)
print(list(filter(lambda x: x % 2 == 0, nums)))
print(list(map(lambda x: x + 100, nums)))
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
# [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119]
```

## 垃圾回收

现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。 python里也同java一样采用了垃圾收集机制，不过不一样的是：python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。

<a href="https://www.jianshu.com/p/9d10a1daaac3">Python垃圾回收机制</a>

## 引用计数机制

python里每一个东西都是对象，它们的核心就是一个结构体：PyObject
PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。当引用计数为0时，该对象生命就结束了。

引用计数机制的优点：

- 简单
- 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。

引用计数机制的缺点：

- 维护引用计数消耗资源
- 循环引用


```python
# 循环引用
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
```

查看一个对象的引用计数

```python
import sys

a = "hello world"
sys.getrefcount(a)
# 可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1
```

循环引用导致内存泄露

```python
import gc


class ClassA:
    def __init__(self):
        print('object born,id:%s' % str(hex(id(self))))


def f2():
    while True:
        c1 = ClassA()
        c2 = ClassA()
        c1.t = c2
        c2.t = c1
        del c1
        del c2


# 把python的gc关闭
gc.disable()
f2()
```

执行f2()，进程占用的内存会不断增大。创建了c1，c2后这两块内存的引用计数都是1。执行c1.t=c2和c2.t=c1后，这两块内存的引用计数变成2。在del c1后，内存1的对象的引用计数变为1，由于不是为0，所以内存1的对象不会被销毁，所以内存2的对象的引用数依然是2，在del c2后，同理，内存1的对象，内存2的对象的引用数都是1。虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。

## gc

```python
import gc


class ClassA:
    def __init__(self):
        print('object born,id:%s' % str(hex(id(self))))
        # def __del__(self):
        #     print('object del,id:%s'%str(hex(id(self))))


def f3():
    print("-----0------")
    # print(gc.collect())
    c1 = ClassA()
    c2 = ClassA()
    c1.t = c2
    c2.t = c1
    print("-----1------")
    del c1
    del c2
    print("-----2------")
    print(gc.garbage)
    print("-----3------")
    print(gc.collect())  # 显式执行垃圾回收
    print("-----4------")
    print(gc.garbage)
    print("-----5------")


if __name__ == '__main__':
    gc.set_debug(gc.DEBUG_LEAK)  # 设置gc模块的日志
    f3()
```

垃圾回收后的对象会放在gc.garbage列表里面，gc.collect()会返回不可达的对象数目，4等于两个对象以及它们对应的dict。

有三种情况会触发垃圾回收：

- 调用gc.collect()
- 当gc模块的计数器达到阀值的时候
- 程序退出的时候

**常用功能解析**

gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。

常用函数

```
1、gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK。
2、gc.collect([generation]) 显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。 返回不可达（unreachable objects）对象的数目。
3、gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率。
4、gc.set_threshold(thres率。hold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率。
5、gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表。
```

**gc模块的自动垃圾回收机制**

```
必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。这个机制的主要作用就是发现并处理不可达的垃圾对象。
垃圾回收=垃圾检查+垃圾回收
```

在Python中，采用分代收集的方法。
把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。

gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数。

```
gc模快有一个自动垃圾回收的阀值，即通过gc.get_threshold函数获取到的长度为3的元组，默认(700,10,10) 每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器。例如，假设阀值是(700,10,10)：
当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)
当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)
当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)
```

注意点

```
gc模块唯一处理不了的是循环引用的类都有__del__方法，所以项目中要避免定义__del__方法
```


## 可用列表

实际上，早在代码开始执行前，Ruby就提前创建了成百上千个对象，并把它们串在链表上，名曰：可用列表。
当我们调用 Node.new，Ruby只需取一个预创建对象给我们使用即可。

## Python 的对象分配

尽管由于许多原因Python也使用可用列表(用来回收一些特定对象比如list)，但在为新对象和变量分配内存的方面Python和Ruby是不同的。与Ruby不同，当创建对象时Python立即向操作系统请求内存。（Python实际上实现了一套自己的内存分配系统，在操作系统堆之上提供了一个抽象层）当我们创建第二个对象的时候，再次像OS请求内存。

## 引用计数

Python与Ruby的垃圾回收机制颇为不同。在内部，创建一个对象时，Python总是在对象的C结构体里保存一个整数，称为引用数。每当对象的引用数减为0，Python立即将其释放，把内存还给操作系统 Python的这种垃圾回收算法被称为引用计数。

## 标记-清除

在Ruby程序运行了一阵子以后，可用列表最终被用光光了。此刻所有Ruby预创建对象都被程序用过了，可用列表里空空如也。Ruby把程序停下来，之后Ruby轮询所有指针，变量和代码产生别的引用对象和其他值。同时Ruby通过自身的虚拟机便历内部指针。标记出这些指针引用的每个对象。在内部，Ruby实际上使用一串位值来跟踪对象是否被标记了。如果说被标记的对象是存活的，剩下的未被标记的对象只能是垃圾。接下来Ruby清除这些无用的垃圾对象，把它们送回到可用列表中。Ruby实际上不会把对象从这拷贝到那。而是通过调整内部指针，将其指向一个新链表的方式，来将垃圾对象归位到可用列表中的。等到下回再创建对象的时候Ruby又可以把这些垃圾对象分给我们使用了。

## 标记-删除 vs 引用计数

许多语言不像Python这样使用引用计数GC算法。

首先，它不好实现。Python不得不在每个对象内部留一些空间来处理引用数，这样付出了一小点儿空间上的代价。但更糟糕的是，每个简单的操作（像修改变量或引用）都会变成一个更复杂的操作，因为Python需要增加一个计数，减少另一个，还可能释放对象。

第二点，它相对较慢。虽然Python随着程序执行GC很稳健，但这并不一定更快。Python不停地更新着众多引用数值。特别是当你不再使用一个大数据结构的时候，比如一个包含很多元素的列表，Python可能必须一次性释放大量对象减少引用数就成了一项复杂的递归过程了。

最后，它不是总奏效，引用计数不能处理环形数据结构--也就是含有循环引用的数据结构。(循环引用 一组未使用的、互相指向的对象，但是谁都没有外部引用)

## 分代收集

Python在引用计数之外，还用了另一个名为Generational Garbage Collection的算法。正如Ruby使用一个链表(free list)来持续追踪未使用的、自由的对象一样，Python使用一种不同的链表来持续追踪活跃的对象。Python的内部C代码将其称为零代(Generation Zero)。每次当你创建一个对象或其他什么值的时候，Python会将其加入零代链表。这并不是一个真正的列表，并不能直接在你的代码中访问，事实上这个链表是一个完全内部的Python运行时。

## 检测循环引用

随后，Python会循环遍历零代列表上的每个对象，检查列表中每个互相引用的对象，根据规则减掉其引用计数。
在这个过程中，Python会一个接一个的统计内部引用的数量以防过早地释放对象。通过识别内部引用，Python能够减少许多零代链表对象的引用计数引用计数已经变为零了，这意味着收集器可以释放它们并回收内存空间了。
剩下的活跃的对象则被移动到一个新的链表：一代链表。

Python的GC算法类似于Ruby所用的标记回收算法。周期性地从一个对象到另一个对象追踪引用以确定对象是否还是活跃的，正在被程序所使用的，这正类似于Ruby的标记过程。

## Python中的GC阈值

程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值。Python会将剩下的活跃对象移动到二代列表。通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。Python处理零代最为频繁，其次是一代然后才是二代。

## 弱代假说

垃圾回收器会更频繁的处理新对象
大部分的新对象都是很快变成垃圾。然而，偶尔程序会创建一些很重要的，存活时间比较长的对象。通过频繁的处理零代链表中的新对象，Python的垃圾收集器将把时间花在更有意义的地方。它处理那些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足阈值的条件，收集器才回去处理那些老变量。

## 小整数对象池

PyCharm中运行

```python
a = -5
b = -5
print(id(a), id(b))
print(id(a) == id(b))
# 1539006496 1539006496
# True

a = -6
b = -6
print(id(a), id(b))
print(id(a) == id(b))
# 2982548101040 2982548101008
# False

a = 1000
b = 1000
print(id(a), id(b))
print(id(a) == id(b))
del a, b
print(id(1000))
# 1651623690032 1651623690032
# True
# 1651623690032

a = 'a' * 20
b = 'a' * 20
print(id(a), id(b))
print(id(a) == id(b))
# 2887929679784 2887929679784
# True

a = 'a' * 19 + '*'
b = 'a' * 19 + '*'
print(a, b)
print(id(a), id(b))
print(id(a) == id(b))
# aaaaaaaaaaaaaaaaaaa* aaaaaaaaaaaaaaaaaaa*
# 3105931120552 3105933235448
# False

a = 'a' * 21
b = 'a' * 21
print(id(a), id(b))
print(id(a) == id(b))
# 1480715118032 1480715849640
# False

a = 'a b'
b = 'a b'
print(id(a), id(b))
print(id(a) == id(b))
# 1685243463248 1685243463248
# True

a = []
b = []
print(id(a), id(b))
print(id(a) == id(b))
# 2355640047880 2355641783880
# False

a = 1356
b = 1356
print(id(a), id(b))
print(id(a) == id(b))
del a, b
print(id(1356))
# 1971651247920 1971651247920
# True
# 1971651247920
```

## 小整数对象池

整数在程序中的使用非常广泛，Python为了优化速度使用了小整数对象池，避免为整数频繁申请和销毁内存空间。Python对小整数的定义是 [-5, 257) 这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象。同理，单个字母也是这样的。但是当定义2个相同的字符串时，引用计数为0，触发垃圾回收

## 大整数对象池

每一个大整数，均创建一个新的对象。

## intern机制

## 总结

- 小整数[-5,257)共用对象，常驻内存
- 单个字符共用对象，常驻内存
- 字符串长度在20个以内没有特殊字符共用对象

- 单个单词，不可修改，默认开启intern机制，共用对象，引用计数为0，则销毁

- 字符串（含有空格/特殊字符），不可修改，没开启intern机制，不共用对象，引用计数为0，销毁

- 大整数不共用内存，引用计数为0，销毁

- 数值类型和字符串类型在 Python 中都是不可变的，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象